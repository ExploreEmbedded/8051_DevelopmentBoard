C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE LCD
OBJECT MODULE PLACED IN .\lcd.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\00-libfiles\lcd.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\00-libfiles) DEB
                    -UG OBJECTEXTEND PRINT(.\lcd.lst) TABS(2) OBJECT(.\lcd.obj)

line level    source

   1          /***************************************************************************************************
   2                                              ExploreEmbedded Copyright Notice    
   3          *****************************************************************************************************
   4           * File:   lcd.c
   5           * Version: 16.0
   6           * Author: ExploreEmbedded
   7           * Website: http://www.exploreembedded.com/wiki
   8           * Description: File contains the Library routines for Alpha Numeric LCD
   9          
  10          This code has been developed and tested on ExploreEmbedded boards.  
  11          We strongly believe that the library works on any of development boards for respective controllers. 
  12          Check this link http://www.exploreembedded.com/wiki for awesome tutorials on 8051,PIC,AVR,ARM,Robotics,RTO
             -S,IOT.
  13          ExploreEmbedded invests substantial time and effort developing open source HW and SW tools, to support con
             -sider buying the ExploreEmbedded boards.
  14           
  15          The ExploreEmbedded libraries and examples are licensed under the terms of the new-bsd license(two-clause 
             -bsd license).
  16          See also: http://www.opensource.org/licenses/bsd-license.php
  17          
  18          EXPLOREEMBEDDED DISCLAIMS ANY KIND OF HARDWARE FAILURE RESULTING OUT OF USAGE OF LIBRARIES, DIRECTLY OR
  19          INDIRECTLY. FILES MAY BE SUBJECT TO CHANGE WITHOUT PRIOR NOTICE. THE REVISION HISTORY CONTAINS THE INFORMA
             -TION 
  20          RELATED TO UPDATES.
  21           
  22          
  23          Permission to use, copy, modify, and distribute this software and its documentation for any purpose
  24          and without fee is hereby granted, provided that this copyright notices appear in all copies 
  25          and that both those copyright notices and this permission notice appear in supporting documentation.
  26          ***************************************************************************************************/
  27          
  28          
  29          
  30          
  31          /***************************************************************************************************
  32                                       Revision History
  33          ****************************************************************************************************
  34          15.0: Initial version 
  35          15.1: Updated the LCD_DisplayNumber function to display Bin/Dec/Hex numbers.
  36                Removed the functions LCD_DisplayHexNumber and LCD_DisplayBinaryNumber.
  37                Changed the structure prefix from STK to STR.
  38          ***************************************************************************************************/
  39          
  40          
  41          /***************************************************************************************************
  42                                             2x16 LCD internal structure
  43          ****************************************************************************************************
  44              
  45                      |<--------------------16 chars on Each Line-------------------->|
  46                     ____________________________________________________________________    
  47                    |\                                                                  /|
  48                    | \ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___/ |
  49                    |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | |
  50              Line0 |  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F | |
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 2   

  51                    |  |___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___| |
  52                    |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | |
  53              Line1 |  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F | |
  54                    |  |___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___| |
  55                    | /                                                                \ |
  56                    |/__________________________________________________________________\|
  57                                  | D7 D6 D5 D4 D3 D2 D1 D0 |     EN   RW   RS          
  58                                  |<------Lcd Data Bus----->|    Lcd control Lines
  59                                  |                         |          
  60          ***************************************************************************************************/      
             -                             
  61          #include <stdarg.h>
  62          #include "delay.h"
  63          #include "lcd.h"
  64          #include "gpio.h"
  65          
  66          
  67          
  68          /***************************************************************************************************
  69                                    Global Variables and Structures
  70          ****************************************************************************************************/
  71          uint8_t v_LcdTrackLineNum_U8;         //Variable to track the line numbers
  72          uint8_t v_LcdTrackCursorPos_U8;       //Variable to track the cursor
  73          LcdConfig_st LCDConfig;               //Structure containing the selected LCD Configuration
  74          uint8_t ARR_LcdLineNumAddress_U8[]={0x80,0xc0,0x90,0xd0};
  75          /**************************************************************************************************/
  76          
  77          
  78          
  79          
  80          /***************************************************************************************************
  81                                      local function prototypes
  82          ***************************************************************************************************/
  83          static void lcd_DataWrite( uint8_t dat);
  84          static void lcd_BusyCheck(void);
  85          static void lcd_Reset(void);
  86          static void lcd_SendCmdSignals(void);
  87          static void lcd_SendDataSignals(void);
  88          static void lcd_SendHigherNibble(uint8_t dataByte);
  89          static void lcd_SendLowerNibble(uint8_t dataByte);
  90          /**************************************************************************************************/
  91          
  92          
  93          
  94          
  95          
  96          /**************************************************************************************************
  97          void LCD_SetUp( pin numbers of lcd)
  98          ***************************************************************************************************
  99           * Function name:  LCD_SetUp()
 100           * I/P Arguments: gpioPins_et RS: Pin where RS is connected 
 101                            gpioPins_et RW: Pin where RW is connected (P_NC if not connected) 
 102                            gpioPins_et EN: Pin where EN is connected
 103                            
 104                            gpioPins_et D0: Pin where D0 is connected (P_NC if not connected for 4-bit mode)  
 105                            gpioPins_et D1: Pin where D1 is connected (P_NC if not connected for 4-bit mode)  
 106                            gpioPins_et D2: Pin where D2 is connected (P_NC if not connected for 4-bit mode)  
 107                            gpioPins_et D3: Pin where D3 is connected (P_NC if not connected for 4-bit mode) 
 108                            gpioPins_et D4: Pin where D4 is connected 
 109                            gpioPins_et D5: Pin where D5 is connected 
 110                            gpioPins_et D6: Pin where D6 is connected 
 111                            gpioPins_et D7: Pin where D7 is connected 
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 3   

 112           * Return value    : none
 113          
 114           * description  :This function is used to configure the controller pins for LCD operation.
 115                           Pass the pin numbers where the RS,RW,EN, D0-D7 are connected as parameters.
 116                           In case of four bit mode pass P_NC as parameter for D0-D3.
 117                           If RW is not used then pass P_NC as parameter for RS.
 118          **************************************************************************************************/
 119          void LCD_SetUp(gpioPins_et RS, 
 120                         gpioPins_et RW, 
 121                         gpioPins_et EN,
 122                         gpioPins_et D0, 
 123                         gpioPins_et D1, 
 124                         gpioPins_et D2, 
 125                         gpioPins_et D3,
 126                         gpioPins_et D4,
 127                         gpioPins_et D5,
 128                         gpioPins_et D6,
 129                         gpioPins_et D7 )
 130          {
 131   1        /* Copy the PIN numbers where the LCD is connected */
 132   1          LCDConfig.RS = RS;
 133   1          LCDConfig.RW = RW;
 134   1          LCDConfig.EN = EN;
 135   1      
 136   1          LCDConfig.D0 = D0;
 137   1          LCDConfig.D1 = D1;
 138   1          LCDConfig.D2 = D2;
 139   1          LCDConfig.D3 = D3;
 140   1          LCDConfig.D4 = D4;
 141   1          LCDConfig.D5 = D5;
 142   1          LCDConfig.D6 = D6;
 143   1          LCDConfig.D7 = D7;
 144   1      
 145   1      
 146   1          if((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC))
 147   1          {
 148   2              LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
 149   2          }
 150   1          else
 151   1          {
 152   2              LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.      
 153   2              GPIO_PinDirection(D0,OUTPUT);
 154   2              GPIO_PinDirection(D1,OUTPUT);
 155   2              GPIO_PinDirection(D2,OUTPUT);
 156   2              GPIO_PinDirection(D3,OUTPUT);
 157   2          }
 158   1      
 159   1          /* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
 160   1          GPIO_PinDirection(RS,OUTPUT);
 161   1          GPIO_PinDirection(RW,OUTPUT);
 162   1          GPIO_PinDirection(EN,OUTPUT);
 163   1      
 164   1          GPIO_PinDirection(D4,OUTPUT);
 165   1          GPIO_PinDirection(D5,OUTPUT);
 166   1          GPIO_PinDirection(D6,OUTPUT);
 167   1          GPIO_PinDirection(D7,OUTPUT);  
 168   1      }
 169          
 170          
 171          /**************************************************************************************************
 172          void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8)
 173          ***************************************************************************************************
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 4   

 174           * Function name:  LCD_Init()
 175           * I/P Arguments:  uint8_t: Number of lines of LCD
 176                             uint8_t: Number of Chars per line
 177           * Return value    : none
 178          
 179           * description  :This function is used to initialize the lcd.
 180                           *It initializes the LCD for selected mode(4/8-bit) and Type(16x2/16x1 etc)
 181          **************************************************************************************************/
 182          void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8)
 183          {
 184   1      
 185   1      
 186   1          LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
 187   1          LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
 188   1          if(v_lcdNoOfLines_u8 > C_LcdLineTwo)
 189   1          {
 190   2              ARR_LcdLineNumAddress_U8[C_LcdLineTwo] =  0x90 + (v_MaxCharsPerLine_u8 & 0x0fu);
 191   2              ARR_LcdLineNumAddress_U8[C_LcdLineThree] =  0xd0 + (v_MaxCharsPerLine_u8 & 0x0fu);
 192   2          }
 193   1      
 194   1          DELAY_ms(100);
 195   1      
 196   1          if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 197   1          {
 198   2              LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 199   2          }
 200   1          else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
 201   1          {
 202   2              lcd_Reset();
 203   2              LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 204   2          }
 205   1      
 206   1          LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
 207   1          LCD_Clear();                             // Clear the LCD and go to First line First Position
 208   1      }
 209          
 210          
 211          
 212          
 213          /***************************************************************************************************
 214                                   void LCD_Clear()
 215          ****************************************************************************************************
 216           * I/P Arguments: none.
 217           * Return value    : none
 218          
 219           * description  :This function clears the LCD and moves the cursor to beginning of first line
 220          ****************************************************************************************************/
 221          void LCD_Clear()
 222          {
 223   1          LCD_CmdWrite(CMD_LCD_CLEAR);    // Clear the LCD and go to First line First Position
 224   1          LCD_GoToLine(C_LcdLineZero);
 225   1      }
 226          
 227          
 228          
 229          
 230          
 231          /***************************************************************************************************
 232                                   void LCD_GoToLine(uint8_t v_lineNumber_u8)
 233          ****************************************************************************************************
 234           * I/P Arguments: uint8_t: Line number.
 235           * Return value    : none
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 5   

 236          
 237           * description  :This function moves the Cursor to beginning of the specified line.
 238                  If the requested line number is out of range, it will not move the cursor.
 239          
 240               Note: The line numbers run from 0 to Maxlines-1,
 241                      To avoid the confusion the below constants has to be used for selecting lines
 242                     For four line LCD the constants are as below:
 243                     C_LcdLineZero,
 244                     C_LcdLineOne,
 245                     C_LcdLineTwo,
 246                     C_LcdLineThree,
 247          
 248          ****************************************************************************************************/
 249          void LCD_GoToLine(uint8_t v_lineNumber_u8)
 250          {
 251   1          if(v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
 252   1          {
 253   2              /* If the line number is within range then
 254   2                 Move the Cursor to beginning of the specified line */
 255   2              v_LcdTrackCursorPos_U8 = 0x00;
 256   2              v_LcdTrackLineNum_U8 = v_lineNumber_u8;
 257   2              LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
 258   2          }
 259   1      }
 260          
 261          
 262          
 263          
 264          
 265          
 266          /***************************************************************************************************
 267                                   void  LCD_GoToNextLine()
 268          ****************************************************************************************************
 269           * I/P Arguments: none
 270           * Return value    : none
 271          
 272           * description  :This function moves the Cursor to beginning of the next line.
 273                  If the cursor is on last line and NextLine command is issued then 
 274                  it will move the cursor to first line.
 275          ****************************************************************************************************/
 276          void  LCD_GoToNextLine(void)
 277          {
 278   1          /*Increment the current line number.
 279   1            In case it exceeds the limit, rool it back to first line */
 280   1          v_LcdTrackLineNum_U8++;
 281   1          v_LcdTrackCursorPos_U8 = 0x00;
 282   1          if(v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
 283   1              v_LcdTrackLineNum_U8 = C_LcdLineZero;
 284   1          LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
 285   1      }
 286          
 287          
 288          
 289          
 290          
 291          
 292          /***************************************************************************************************
 293                          void LCD_SetCursor(char v_lineNumber_u8,char v_charNumber_u8)
 294          ****************************************************************************************************
 295           * I/P Arguments: char row,char col
 296                           row -> line number(line1=1, line2=2),
 297                                  For 2line LCD the I/P argument should be either 1 or 2.
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 6   

 298                           col -> char number.
 299                                  For 16-char LCD the I/P argument should be between 0-15.
 300           * Return value    : none
 301          
 302           * description  :This function moves the Cursor to specified position
 303          
 304                             Note:If the Input(Line/Char number) are out of range 
 305                                  then no action will be taken
 306          ****************************************************************************************************/
 307          #if ( Enable_LCD_SetCursor    == 1 )
              void LCD_SetCursor(uint8_t v_lineNumber_u8, uint8_t v_charNumber_u8)
              {
              
                  if((v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8) &&
                          (v_charNumber_u8< LCDConfig.v_MaxSupportedChars_U8))
                  {
                      /*If the line number and char are in range then
                         move the Cursor to specified Position*/
                      v_LcdTrackCursorPos_U8 = v_charNumber_u8;
                      v_LcdTrackLineNum_U8 = v_lineNumber_u8;
                      LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]+v_charNumber_u8);
                  }
              }
              #endif
 322          
 323          
 324          
 325          
 326          
 327          
 328          
 329          
 330          
 331          /***************************************************************************************************
 332                                 void LCD_CmdWrite( uint8_t v_lcdCmd_u8)
 333          ****************************************************************************************************
 334           * I/P Arguments: 8-bit command supported by LCD.
 335           * Return value    : none
 336          
 337           * description :This function sends a command to LCD.
 338                          Some of the commonly used commands are defined in lcd.h.
 339                          For more commands refer the data sheet and send the supported command.                
 340                          The behaviour is undefined if unsupported commands are sent.    
 341          ****************************************************************************************************/
 342          void LCD_CmdWrite( uint8_t v_lcdCmd_u8)
 343          {
 344   1          lcd_BusyCheck();
 345   1          if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 346   1           {
 347   2               lcd_SendLowerNibble(v_lcdCmd_u8);
 348   2           }
 349   1           else
 350   1           {
 351   2               lcd_SendHigherNibble(v_lcdCmd_u8);
 352   2               lcd_SendCmdSignals();
 353   2               v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
 354   2           }
 355   1      
 356   1           lcd_SendHigherNibble(v_lcdCmd_u8);
 357   1           lcd_SendCmdSignals();
 358   1      }
 359          
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 7   

 360          
 361          
 362          
 363          
 364          
 365          
 366          /***************************************************************************************************
 367                                 void LCD_DisplayChar( char v_lcdData_u8)
 368          ****************************************************************************************************
 369           * I/P Arguments: ASCII value of the char to be displayed.
 370           * Return value    : none
 371          
 372           * description  : This function sends a character to be displayed on LCD.
 373                            Any valid ascii value can be passed to display respective character
 374          
 375          ****************************************************************************************************/
 376          void LCD_DisplayChar(char v_lcdData_u8)
 377          {
 378   1          if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
 379   1          {
 380   2              /* If the cursor has reached to end of line on page1
 381   2              OR NewLine command is issued Then Move the cursor to next line */
 382   2              LCD_GoToNextLine();
 383   2          }
 384   1          if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 385   1          {
 386   2      
 387   2              lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
 388   2              v_LcdTrackCursorPos_U8++;
 389   2          }
 390   1      }
 391          
 392          
 393          
 394          
 395          
 396          
 397          
 398          /***************************************************************************************************
 399                                 void LCD_DisplayString(char *ptr_stringPointer_u8)
 400          ****************************************************************************************************
 401           * I/P Arguments: String(Address of the string) to be displayed.
 402           * Return value    : none
 403          
 404           * description  :
 405                         This function is used to display the ASCII string on the lcd.
 406                           1.The ptr_stringPointer_u8 points to the first char of the string
 407                              and traverses till the end(NULL CHAR)and displays a char each time.
 408          
 409          ****************************************************************************************************/
 410          #if (Enable_LCD_DisplayString==1)
 411          void LCD_DisplayString(char *ptr_stringPointer_u8)
 412          {
 413   1          while((*ptr_stringPointer_u8)!=0)
 414   1              LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
 415   1      }
 416          #endif
 417          
 418          
 419          
 420          
 421          
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 8   

 422          
 423          
 424          /***************************************************************************************************
 425                         void LCD_ScrollMessage(uint8_t v_lineNumber_u8, char *ptr_msgPointer_u8)
 426          ****************************************************************************************************
 427           * I/P Arguments: 
 428                            uint8_t  : Line number on which the message has to be scrolled
 429                            char *: pointer to the string to be scrolled                      
 430          
 431           * Return value    : none
 432          
 433           * description  :This function scrolls the given message on the specified line.
 434                           If the specified line number is out of range then the message
 435                           will be scrolled on first line
 436          ****************************************************************************************************/
 437          #if ( Enable_LCD_ScrollMessage  == 1 )
              void LCD_ScrollMessage(uint8_t v_lineNumber_u8, char *ptr_msgPointer_u8)
              {
                  unsigned char i,j;
              
              
                  if(v_lineNumber_u8 >= LCDConfig.v_MaxSupportedLines_U8)
                      v_lineNumber_u8 = C_LcdLineZero; // Select first line if the v_lineNumber_u8 is out of range
              
                  LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);             //Disable the Cursor
              
                  for(i=0;ptr_msgPointer_u8[i];i++)
                  {      
                      /* Loop to display the complete string,    each time 16 chars are displayed and
                      pointer is incremented to point to next char */
              
              
                      LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line
              
                      for(j=0;(j<LCDConfig.v_MaxSupportedChars_U8) && (ptr_msgPointer_u8[i+j]);j++)
                      {
                          //Display first 16 Chars or till Null char is reached
                          LCD_DisplayChar(ptr_msgPointer_u8[i+j]);
                      }
              
              
                      while( j<LCDConfig.v_MaxSupportedChars_U8)
                      {
                          /*If the chars to be scrolled are less than MaxLcdChars,
                            then display remaining chars with blank spaces*/
                          LCD_DisplayChar(' ');
                          j++;
                      }
              
                      DELAY_ms(C_ScrollDelayTime_U8);
                  }
                  LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);              // Finally enable the Cursor
              }
              #endif
 476          
 477          
 478          
 479          
 480          
 481          
 482          /***************************************************************************************************
 483          void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 9   

             -8)
 484          ****************************************************************************************************
 485           * Function name:  LCD_DisplayNumber()
 486           * I/P Arguments: 
 487                            uint8_t :  specifies type of number C_BINARY_U8(2),C_DECIMAL_U8(10), C_HEX_U8(16)
 488                            uint32_t: Number to be displayed on the LCD.
 489                            uint8_t : Number of digits to be displayed
 490                            
 491           * Return value    : none
 492          
 493           * description  :This function is used to display a max of 10digit decimal/Hex number OR specified 
 494                           number of bits for binary number.
 495                          
 496                          1st parameter specifies type of number C_BINARY_U8(2),C_DECIMAL_U8(10), C_HEX_U8(16)      
             -           
 497                          3rd parameter specifies the number of digits from the right side to be displayed
 498                           The output for the input combinations is as below
 499                         
 500              Binary:     1.(2,10,4) then 4-LSB will be displayed ie. 1010
 501                          2.(C_BINARY_U8,10,8) then 8-LSB will be displayed ie. 00001010
 502                          3.(C_BINARY_U8,10,2) then 2-LSB will be displayed ie. 10
 503                          
 504              Decimal:    4.(10,12345,4) then 4-digits ie. 2345 will be displayed
 505                          5.(C_DECIMAL_U8,12345,6) then 6-digits ie. 012345 will be displayed
 506                          6.(10,12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.\
 507                          
 508              Hex:        7.(16,0x12AB,3) then 3-digits ie. 2AB will be displayed
 509                          8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
 510                          9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.                
 511          ****************************************************************************************************/
 512          #if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
              void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u
             -8)
              {
                  uint8_t i=0,a[10];
                  
                  if(C_BINARY_U8 == v_numericSystem_u8)
                  {
                      while(v_numOfDigitsToDisplay_u8!=0)
                      {
                        /* Start Extracting the bits from the specified bit positions.
                        Get the Acsii values of the bits and display */
                        i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
                        LCD_DisplayChar(util_Dec2Ascii(i));
                        v_numOfDigitsToDisplay_u8--;
                      }        
                  }    
                  else if(v_number_u32==0)
                  {
                      /* If the number is zero then update the array with the same for displaying */
                      for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
                          LCD_DisplayChar('0');
                  }
                  else
                  {
                      for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
                      {
                          /* Continue extracting the digits from right side
                             till the Specified v_numOfDigitsToDisplay_u8 */
                          if(v_number_u32!=0)
                          {
                              /* Extract the digits from the number till it becomes zero.
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 10  

                              First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                              
                              example for Decimal number: 
                              If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                              The process continues till it becomes zero or max digits reached*/
                              a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
                              v_number_u32=v_number_u32/v_numericSystem_u8;
                          }
                          else if( (v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
                                   (v_numOfDigitsToDisplay_u8 > C_MaxDigitsToDisplay_U8))
                          {
                              /* Stop the iteration if the Max number of digits are reached or 
                               the user expects exact(Default) digits in the number to be displayed */ 
                              break;
                          }
                          else
                          {
                              /* In case user expects more digits to be displayed than the actual digits in number,
                                then update the remaining digits with zero.
                             Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                              a[i]=0;
                          }
                      }
                      
                       while(i!=0)
                      { 
                        /* Finally get the ascii values of the digits and display*/
                        LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
                        i--;
                      }
                  }
              }
              #endif
 576          
 577          
 578          
 579          
 580          
 581          
 582          
 583          
 584          /*************************************************************************************************
 585                      void  LCD_DisplayFloatNumber(double v_floatNum_f32)
 586          **************************************************************************************************
 587           * Function name:  LCD_DisplayFloatNumber()
 588           * I/P Arguments: float: float Number to be displayed on the LCD.
 589          
 590           * Return value    : none
 591          
 592           * description  :This function is used to display a floating point number
 593                           It supports 6digits of precision.
 594          
 595              Note: Float will be disabled by default as it takes huge controller resources
 596                   It can be enabled by changing value of Enable_LCD_DisplayFloatNumber to 1 in lcd.h
 597          ***************************************************************************************************/
 598          #if (Enable_LCD_DisplayFloatNumber == 1)  
              void LCD_DisplayFloatNumber(double v_floatNum_f32)
              {
                  uint32_t v_temp_u32;
                  /* Dirty hack to support the floating point by extracting the integer and fractional part.
                    1.Type cast the number to int to get the integer part.
                    2.Display the extracted integer part followed by a decimal point(.)
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 11  

                    3.Later the integer part is made zero by subtracting with the extracted integer value.
                    4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */
              
                  v_temp_u32 = (uint32_t) v_floatNum_f32;
                  LCD_DisplayNumber(C_DECIMAL_U8,v_temp_u32,C_DisplayDefaultDigits_U8);
              
                  LCD_DisplayChar('.');
              
                  v_floatNum_f32 = v_floatNum_f32 - v_temp_u32;
                  v_temp_u32 = v_floatNum_f32 * 1000000;
                  LCD_DisplayNumber(C_DECIMAL_U8,v_temp_u32,C_DisplayDefaultDigits_U8);
              }
              #endif
 618          
 619          
 620          
 621          
 622          
 623          
 624          /*************************************************************************************************
 625                      void LCD_Printf(const char *argList, ...)
 626          **************************************************************************************************
 627           * Function name:  LCD_Printf()
 628           * I/P Arguments: variable length arguments similar to printf
 629          
 630           * Return value    : none
 631          
 632           * description  :This function is similar to printf function in C.
 633                           It takes the arguments with specified format and prints accordingly
 634                           The supported format specifiers are as below.
 635                           1. %c: character
 636                           2. %d: signed 16-bit number
 637                           3. %D: signed 32-bit number
 638                           4. %u: unsigned 16-bit number
 639                           5. %U: unsigned 32-bit number
 640                           6. %b: 16-bit binary number
 641                           7. %B: 32-bit binary number
 642                           8. %f: Float number
 643                           9. %x: 16-bit hexadecimal number
 644                           10. %X: 32-bit hexadecimal number
 645                           11. %s: String
 646          
 647          
 648          
 649            Extra feature is available to specify the number of digits to be displayed using printf.
 650               ex: %4d: will display the lower four digits of the decimal number.
 651                   %12b: will display the 12-LSB of the number
 652                   %d: Will display the exact digits of the number
 653          
 654          #####: In case of printing the 8-bit variables, it is recommended to type cast and promote them to uint16_
             -t.
 655                  uint8_t v_Num_u8;
 656                  LCD_Printf("num1:%u",(uint16_t)v_Num_u8); 
 657          **************************************************************************************************/
 658          #if ( Enable_LCD_Printf   == 1 ) 
              void LCD_Printf(const char *argList, ...)
              {
                  const char *ptr;
                  va_list argp;
                  sint16_t v_num_s16;
                  sint32_t v_num_s32;
                  uint16_t v_num_u16;
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 12  

                  uint32_t v_num_u32;
                  char *str;
                  char  ch;
                  uint8_t v_numOfDigitsToDisp_u8;
              #if (Enable_LCD_DisplayFloatNumber == 1)  
                  double v_floatNum_f32;
              #endif
              
                  va_start(argp, argList);
              
                  /* Loop through the list to extract all the input arguments */
                  for(ptr = argList; *ptr != '\0'; ptr++)
                  {
              
                      ch= *ptr;
                      if(ch == '%')         /*Check for '%' as there will be format specifier after it */
                      {
                          ptr++;
                          ch = *ptr;
                         if((ch>=0x30) && (ch<=0x39))
                          {
                             v_numOfDigitsToDisp_u8 = 0;
                             while((ch>=0x30) && (ch<=0x39))
                              {
                                 v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
                                 ptr++;
                                 ch = *ptr;
                              }
                          }
                          else
                          {
                            v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
                          }                
              
              
                          switch(ch)       /* Decode the type of the argument */
                          {
                          case 'C':
                          case 'c':     /* Argument type is of char, hence read char data from the argp */
                              ch = va_arg(argp, int);
                              LCD_DisplayChar(ch);
                              break;
              
                          case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
                              v_num_s16 = va_arg(argp, int);
                              if(v_num_s16<0)
                               { /* If the number is -ve then display the 2's complement along with '-' sign */ 
                                 v_num_s16 = -v_num_s16;
                                 LCD_DisplayChar('-');
                               }
                              LCD_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
                              break;
                              
                          case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
                              v_num_s32 = va_arg(argp, sint32_t);
                              if(v_num_s32<0)
                               { /* If the number is -ve then display the 2's complement along with '-' sign */
                                 v_num_s32 = -v_num_s32;
                                 LCD_DisplayChar('-');
                               }
                              LCD_DisplayNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToDisp_u8);              
                              break;    
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 13  

              
                          case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
                              v_num_u16 = va_arg(argp, int);
                              LCD_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                              break;
                          
                          case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
                              v_num_u32 = va_arg(argp, uint32_t);
                              LCD_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);               
                              break;            
              
                          case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
                              v_num_u16 = va_arg(argp, int);
                              LCD_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                              break;
              
                          case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
                              v_num_u32 = va_arg(argp, uint32_t);
                              LCD_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
                              break;
              
                          
                          case 'b':  /* Argument type is of binary,Read int and convert to binary */
                              v_num_u16 = va_arg(argp, int);
                              if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
                                 v_numOfDigitsToDisp_u8 = 16;
                              LCD_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);                
                              break;
              
                          case 'B':  /* Argument type is of binary,Read int and convert to binary */
                              v_num_u32 = va_arg(argp, uint32_t);
                              if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
                                 v_numOfDigitsToDisp_u8 = 16;                
                              LCD_DisplayNumber(C_BINARY_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
                              break;
              
              
                          case 'F':
                          case 'f': /* Argument type is of float, hence read double data from the argp */
              #if (Enable_LCD_DisplayFloatNumber == 1)  
                              v_floatNum_f32 = va_arg(argp, double);              
                              LCD_DisplayFloatNumber(v_floatNum_f32);
              #endif
                              break;
              
              
                          case 'S':
                          case 's': /* Argument type is of string, hence get the pointer to sting passed */
                              str = va_arg(argp, char *);
                              LCD_DisplayString(str);                
                              break;
              
                          case '%':
                              LCD_DisplayChar('%');
                              break;
                          }
                      }
                      else
                      {
                          /* As '%' is not detected display/transmit the char passed */
                          LCD_DisplayChar(ch);
                      }
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 14  

                  }
              
                  va_end(argp);
              }
              #endif
 795          
 796          
 797          
 798          
 799          
 800          
 801          /*************************************************************************************************
 802                                 static void lcd_DataWrite( uint8_t dat)
 803          **************************************************************************************************
 804           * I/P Arguments: uint8_t: 8-bit value to be sent to LCD.
 805           * Return value    : none
 806          
 807           * description : This functions is used to send a byte of data to LCD.                 .    
 808          **************************************************************************************************/
 809          static void lcd_DataWrite( uint8_t dataByte)
 810          {
 811   1          lcd_BusyCheck();
 812   1          if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 813   1           {
 814   2               lcd_SendLowerNibble(dataByte);
 815   2           }
 816   1           else
 817   1           {
 818   2               lcd_SendHigherNibble(dataByte);
 819   2               lcd_SendDataSignals();
 820   2               dataByte = dataByte << 4;
 821   2           }
 822   1      
 823   1           lcd_SendHigherNibble(dataByte);
 824   1           lcd_SendDataSignals();
 825   1      }
 826          
 827          
 828          
 829          
 830          
 831          
 832          
 833          /*************************************************************************************************
 834                                 static void lcd_BusyCheck()
 835          **************************************************************************************************
 836           * I/P Arguments: none.
 837           * Return value    : none
 838          
 839           * description : This functions is used check whether LCD is busy.
 840                           It waits till the LCD is busy by polling the LCD busy flag.
 841                           After completing the previous operation, LCDs clears its internal busy flag.
 842          **************************************************************************************************/
 843          static void lcd_BusyCheck(void)
 844          {
 845   1          uint8_t busyflag;
 846   1        if(LCDConfig.RW != P_NC)                         //Perform Busy check if RW pin is used
 847   1         {
 848   2          GPIO_PinDirection(LCDConfig.D7,INPUT); // Configure busy pin as input
 849   2          GPIO_PinWrite(LCDConfig.RS,0);           // Select the Command Register by pulling RS LOW
 850   2          GPIO_PinWrite(LCDConfig.RW,1);           // Select the Read Operation for busy flag by setting RW
 851   2          do
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 15  

 852   2          {
 853   3      
 854   3              GPIO_PinWrite(LCDConfig.EN,0);
 855   3              DELAY_us(10);
 856   3              GPIO_PinWrite(LCDConfig.EN,1); 
 857   3              DELAY_us(10);
 858   3              busyflag = GPIO_PinRead(LCDConfig.D7);
 859   3      
 860   3      
 861   3              if(LCDConfig.v_LcdMode_U8 == 4)
 862   3              {
 863   4                  /* Perform extra dummy read for 4-bit */            
 864   4                  GPIO_PinWrite(LCDConfig.EN,0);
 865   4                  DELAY_us(10);
 866   4                  GPIO_PinWrite(LCDConfig.EN,1); 
 867   4                  DELAY_us(10);
 868   4              }    
 869   3          }while(busyflag);
 870   2      
 871   2              GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
 872   2        }
 873   1      else
 874   1       {
 875   2          /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
 876   2            to ensure the LCD completes previous operation and ready to receive new commands/data */
 877   2          DELAY_ms(1);  
 878   2       }
 879   1      }
 880          
 881          
 882          
 883          
 884          
 885          
 886          /*************************************************************************************************
 887                                 static void lcd_Reset()
 888          **************************************************************************************************
 889           * I/P Arguments: none.
 890           * Return value    : none
 891          
 892           * description : This functions is used to reset the LCD. 
 893                           This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
 894          ----------------------------------------------------------------------------------*/
 895          static void lcd_Reset(void)
 896          {
 897   1          /* LCD reset sequence for 4-bit mode, refer data sheet for more info */
 898   1          lcd_SendHigherNibble(0x30);
 899   1          lcd_SendCmdSignals();
 900   1          DELAY_ms(100);
 901   1          lcd_SendHigherNibble(0x30);
 902   1          lcd_SendCmdSignals();
 903   1          DELAY_us(200);
 904   1          lcd_SendHigherNibble(0x30);
 905   1          lcd_SendCmdSignals();
 906   1          DELAY_us(200);
 907   1          lcd_SendHigherNibble(0x20);
 908   1          lcd_SendCmdSignals();
 909   1          DELAY_us(200);
 910   1      }
 911          
 912          
 913          
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 16  

 914          
 915          
 916          
 917          /*************************************************************************************************
 918                                 static void lcd_SendHigherNibble(uint8_t var)
 919          **************************************************************************************************
 920           * I/P Arguments: uint8_t: Higher nibble of the data to be send on LCD4-LCD7 data lines
 921           * Return value    : none
 922          
 923           * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 924          **************************************************************************************************/
 925          static void lcd_SendHigherNibble(uint8_t dataByte)
 926          {
 927   1          GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
 928   1          GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
 929   1          GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
 930   1          GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
 931   1      }
 932          
 933          
 934          
 935          
 936          /*************************************************************************************************
 937                                 static void lcd_SendHigherNibble(uint8_t var)
 938          **************************************************************************************************
 939           * I/P Arguments: uint8_t: Lower nibble of the data to be send on LCD4-LCD7 data lines
 940           * Return value    : none
 941          
 942           * description : This functions is used to send the lower nibble of the data to LCD
 943          **************************************************************************************************/
 944          static void lcd_SendLowerNibble(uint8_t dataByte)
 945          {
 946   1          GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
 947   1          GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
 948   1          GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
 949   1          GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
 950   1      }
 951          
 952          
 953          
 954          
 955          /*************************************************************************************************
 956                                 static void lcd_SendCmdSignals()
 957          **************************************************************************************************
 958           * I/P Arguments: none
 959           * Return value    : none
 960          
 961           * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
 962          **************************************************************************************************/
 963          static void lcd_SendCmdSignals(void)
 964          {
 965   1           GPIO_PinWrite(LCDConfig.RS,0);
 966   1           GPIO_PinWrite(LCDConfig.RW,0);
 967   1           GPIO_PinWrite(LCDConfig.EN,1);
 968   1           DELAY_us(10);
 969   1           GPIO_PinWrite(LCDConfig.EN,0);
 970   1        
 971   1      }
 972          
 973          
 974          
 975          
C51 COMPILER V9.02   LCD                                                                   11/21/2016 11:18:05 PAGE 17  

 976          /*************************************************************************************************
 977                                 static void lcd_SendDataSignals()
 978          ***************************************************************************************************
 979           * I/P Arguments: none
 980           * Return value    : none
 981          
 982           * description : This functions generates the signals for sending the Data to LCD
 983          **************************************************************************************************/
 984          static void lcd_SendDataSignals(void)
 985          {
 986   1           GPIO_PinWrite(LCDConfig.RS,1);
 987   1           GPIO_PinWrite(LCDConfig.RW,0);
 988   1           GPIO_PinWrite(LCDConfig.EN,1);
 989   1           DELAY_us(10);
 990   1           GPIO_PinWrite(LCDConfig.EN,0);
 991   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    778    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
